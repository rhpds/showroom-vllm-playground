= Module 2: Advanced Inferencing: Structured Outputs
:source-highlighter: rouge
:toc: macro
:toclevels: 1

In Module 1, the presenter deployed a vLLM server and demonstrated the chat interface. Now ACME Corporation faces a new challenge: their customer support system needs to integrate AI responses with existing backend systems. Free-form text responses are difficult to parse and process programmatically.

ACME's engineering team requires predictable, structured outputs that downstream systems can reliably consume. vLLM Playground's structured output capabilities, including JSON Schema, Regex, and Grammar, provide exactly this control. This module demonstrates how to constrain LLM outputs to specific formats, ensuring ACME's AI responses are system-ready and consistently parseable.

[[part-1]]
== Part 1 - JSON Schema for API Integration

=== Know

_Customer challenge: ACME's backend systems expect customer support responses in a specific JSON format. The AI must generate responses that conform exactly to the required schema, enabling direct API integration without post-processing._

**Business Impact:**

* Backend systems cannot consume free-form AI text, requiring expensive custom parsing logic
* Manual data entry from AI responses to structured systems costs 15 minutes per ticket
* Inconsistent data formats cause integration failures and data loss
* Engineering time is wasted building brittle text-to-JSON translation layers

**Value Proposition:**

vLLM's JSON Schema mode constrains model output to a defined schema at the decoding level. This guarantees every response is valid, parseable JSON that conforms to the exact structure backend systems expect, eliminating post-processing entirely.

=== Show

**What I say:**

"ACME's backend systems need structured data, not free-form text. Let me show you how vLLM can guarantee every AI response is valid JSON that matches the exact schema your APIs expect."

**What I do:**

. For structured outputs to work reliably, a more capable model than TinyLlama is needed. Stop the current server if running, then configure a new server with `Qwen/Qwen2.5-3B-Instruct`:
+
.. Click *Stop Server* if a server is currently running
.. In the *Model* section, select or enter: `Qwen/Qwen2.5-3B-Instruct`
.. Ensure *Container* mode and *GPU* mode are selected
.. Click *Start Server*
+
NOTE: Qwen2.5-3B-Instruct is a 3 billion parameter model that provides better instruction-following capabilities for structured output tasks while still being fast on GPU.

. Wait for the server to be ready (green "Server is ready to chat!" notification).

. Navigate to the *Structured Outputs* section in the toolbar panel.
. Click "Enable Structured Outputs".
+
image::module-02-figure-01.png[Structured outputs configuration panel showing Enable checkbox and Output Type options,align="center",width=600,link=module-02-figure-01.png^,title="Structured Outputs Panel"]

. In the *Structured Outputs* panel, select *JSON* mode.
+
image::module-02-figure-04.png[JSON Schema configuration in structured outputs panel,align="center",width=600,link=module-02-figure-04.png^,title="JSON Schema Mode"]

. Define a schema for customer support ticket extraction:
+
[source,json]
----
{
  "type": "object",
  "properties": {
    "ticket_type": {
      "type": "string",
      "enum": ["billing", "technical", "general", "complaint", "feature_request"]
    },
    "priority": {
      "type": "string",
      "enum": ["low", "medium", "high", "urgent"]
    },
    "summary": {
      "type": "string",
      "maxLength": 100
    },
    "customer_sentiment": {
      "type": "string",
      "enum": ["positive", "negative", "neutral"]
    },
    "requires_escalation": {
      "type": "boolean"
    }
  },
  "required": ["ticket_type", "priority", "summary", "customer_sentiment", "requires_escalation"]
}
----

. Set a system prompt for ticket extraction:
+
----
You are a customer support ticket classifier. Extract structured information from customer messages and output a JSON object with ticket_type, priority, summary, customer_sentiment, and requires_escalation fields.
----

. Test with a sample customer message:
+
----
Customer message: "I've been charged twice for my subscription this month! This is unacceptable and I want a refund immediately. I've been a loyal customer for 3 years and this is how you treat me?"
----
+
Expected output (formatted):
+
[source,json]
----
{
  "ticket_type": "billing",
  "priority": "high",
  "summary": "Customer charged twice for subscription, requesting immediate refund",
  "customer_sentiment": "negative",
  "requires_escalation": true
}
----
+
image::module-02-figure-05.png[JSON Schema output showing structured ticket extraction,align="center",width=600,link=module-02-figure-05.png^,title="JSON Schema Structured Output"]

. Test with a different scenario:
+
----
Customer message: "Hey, just wondering if you have any plans to add dark mode to the mobile app? Would be really nice to have. Thanks!"
----
+
Expected output (formatted):
+
[source,json]
----
{
  "ticket_type": "feature_request",
  "priority": "low",
  "summary": "Request for dark mode in mobile app",
  "customer_sentiment": "positive",
  "requires_escalation": false
}
----

. Verify the output is valid JSON by checking the response panel shows proper formatting.

**What they should notice:**

* Output is valid JSON with no syntax errors
* All required fields are present in every response
* Enum values match the defined options exactly
* Boolean field is true/false, not a string
* No extra text, explanations, or formatting outside the JSON structure

image::module-02-figure-06.png[Verified JSON output displayed in the response panel,align="center",width=600,link=module-02-figure-06.png^,title="Verified JSON Format"]

TIP: The vLLM Playground response panel already validates JSON formatting. If the output displays properly formatted, it is valid JSON.

**If asked:**

Q: "Can we validate the JSON output programmatically?"
A: "Yes. You can save the output and validate it with Python:"

[source,bash]
----
# You can validate the JSON output by saving it to a file and using Python
cat << 'EOF' > /tmp/output.json
<paste_your_json_output_here>
EOF
python3 -c "import json; print(json.load(open('/tmp/output.json')))"
----

Q: "What happens if the model tries to output invalid enum values?"
A: "The guided decoding engine rejects invalid tokens at generation time. The model physically cannot produce values outside the schema definition."

Q: "Does this work with nested JSON schemas?"
A: "Yes, vLLM supports nested objects, arrays, and complex schema compositions including allOf, anyOf, and oneOf."

[[part-2]]
== Part 2 - Choice Mode (Optional)

=== Know

_Customer challenge: ACME's customer support team receives thousands of feedback messages daily. Before routing to the appropriate team, they need to automatically classify the sentiment of each message. The classification must be consistent and machine-readable._

**Business Impact:**

* Manual sentiment review consumes 20 hours per day across the support team
* Inconsistent categorization leads to misrouted tickets and delayed responses
* Free-form AI responses require additional parsing to extract a simple classification
* Negative feedback sits undetected for up to 30 minutes during manual triage

**Value Proposition:**

vLLM's Choice mode constrains the model to output exactly one value from a predefined list. For simple classification tasks like sentiment analysis, this eliminates all ambiguity and ensures 100% machine-readable output with zero post-processing.

=== Show

**What I say:**

"For simple classification tasks, sometimes all you need is a single label from a fixed set of options. Choice mode makes that trivially easy."

**What I do:**

. Click the *Clear* button in the Chat Interface to start a new conversation.

. In the *Structured Outputs* panel, select *Choice* mode for simple constrained outputs.

. Configure the sentiment choices:
+
[source,json]
----
["positive", "negative", "neutral"]
----
+
This constrains the model to output ONLY one of these three values.

. Set a system prompt for sentiment analysis:
+
----
You are a sentiment classifier. Analyze the customer feedback and respond with exactly one word: positive, negative, or neutral. No other output.
----

. Test with sample customer feedback:
+
----
Feedback: "I absolutely love your product! It exceeded all my expectations and the customer service was fantastic."
----
+
Expected output: `positive`
+
image::module-02-figure-02.png[Chat interface showing sentiment analysis with Choice mode outputting positive,align="center",width=600,link=module-02-figure-02.png^,title="Sentiment Analysis with Choice Mode"]

. Test with negative feedback:
+
----
Feedback: "Terrible experience. The product arrived broken and nobody responded to my support ticket for a week."
----
+
Expected output: `negative`

. Test with neutral feedback:
+
----
Feedback: "The product works as described. Delivery was on time. Nothing special but nothing wrong either."
----
+
Expected output: `neutral`
+
image::module-02-figure-03.png[Sentiment analysis showing neutral classification result,align="center",width=600,link=module-02-figure-03.png^,title="Neutral Sentiment Classification"]

**What they should notice:**

* Model outputs ONLY one of the three allowed values
* No additional text, explanations, or formatting
* Consistent classification across similar inputs
* Response time is fast because the output is a single token

**If asked:**

Q: "How is this different from just asking the model to pick one?"
A: "Without Choice mode, the model might output 'The sentiment is positive' or 'I would classify this as positive.' Choice mode guarantees the output is exactly one of the defined values, nothing more."

Q: "Can we use more than three choices?"
A: "Yes. You can define any number of string values in the choice array. For example, a five-point scale: very_positive, positive, neutral, negative, very_negative."

Q: "What about multi-label classification?"
A: "For multi-label scenarios, JSON Schema mode is more appropriate. You can define an array field that accepts multiple enum values."

[[part-3]]
== Part 3 - Regex & Grammar (Optional)

=== Know

_Customer challenge: ACME's ticketing system requires specific ID formats for tracking, and their analytics team needs AI-generated reports in a specific markup format. These requirements go beyond simple JSON or single-value outputs._

**Business Impact:**

* Inconsistent ticket ID formats break tracking across systems, causing 50 lost tickets per month
* Manual reformatting of AI-generated report content costs 10 hours per week
* Custom parsing logic for non-standard output formats is fragile and expensive to maintain
* Lack of format enforcement means downstream systems silently drop malformed data

**Value Proposition:**

vLLM provides two additional constraint modes for specialized formatting needs. Regex patterns enforce precise string formats like IDs and codes. Grammar rules (GBNF format) handle complex structured output like custom markup and reports.

=== Show

**What I say:**

"JSON and Choice modes cover most use cases, but sometimes you need exact string formats or custom markup structures. Regex and Grammar modes handle those edge cases."

**What I do:**

. Click the *Clear* button in the Chat Interface to start a new conversation.

. In the *Structured Outputs* panel, select *Regex* mode.

. Define a pattern for ACME ticket IDs:
+
[source,text]
----
ACME-[A-Z]{4}-[0-9]{4}
----
+
This pattern enforces:
* Literal prefix `ACME-`
* Exactly 4 uppercase letters
* A hyphen `-`
* Exactly 4 digits
+
image::module-02-figure-07.png[Regex pattern configuration in structured outputs panel,align="center",width=600,link=module-02-figure-07.png^,title="Regex Mode"]

. Set a system prompt:
+
----
Generate a unique ticket ID for the customer support system. Output only the ticket ID, nothing else.
----

. Test the Regex constraint:
+
----
Generate a ticket ID for a new billing inquiry.
----
+
Expected output format: `ACME-BXYZ-1234` (exact letters/numbers will vary)
+
image::module-02-figure-08.png[Regex output showing ACME ticket ID format,align="center",width=600,link=module-02-figure-08.png^,title="Regex Constrained Output"]

. Verify the format matches:
* Starts with `ACME-`
* Followed by 4 uppercase letters
* Then a hyphen
* Ends with 4 digits

. Try a more complex Regex for phone number formatting:
+
[source,text]
----
\(\d{3}\) \d{3}-\d{4}
----
+
This enforces US phone format: `(XXX) XXX-XXXX`

. Test with prompt:
+
----
Format this phone number: 5551234567
----
+
Expected output: `(555) 123-4567`
+
image::module-02-figure-09.png[Regex output showing formatted phone number,align="center",width=600,link=module-02-figure-09.png^,title="Phone Number Formatting with Regex"]

[source,bash]
----
# Validate ticket ID format with grep
echo "ACME-WXYZ-1234" | grep -E "^ACME-[A-Z]{4}-[0-9]{4}$"
----

**What they should notice:**

* Output matches the exact Regex pattern every time
* No extra characters or whitespace
* Pattern is consistently applied across multiple generations

**What I say:**

"Now let me show Grammar mode for more complex output structures, like custom report formats."

**What I do:**

. Click the *Clear* button in the Chat Interface to start a new conversation.

. In the *Structured Outputs* panel, select *Grammar* mode.

. Grammar uses GBNF (GGML BNF) format. Define a simple report structure:
+
[source,text]
----
root ::= report
report ::= header sections footer
header ::= "## REPORT START ##\n"
sections ::= section+
section ::= section-title bullet-list "\n"
section-title ::= "### " [A-Za-z ]+ " ###\n"
bullet-list ::= bullet+
bullet ::= "- " [A-Za-z0-9 ,.]+ "\n"
footer ::= "## REPORT END ##"
----
+
This grammar enforces:
* Report wrapped in START/END markers
* One or more sections with titles
* Bullet lists within each section

. Set a system prompt:
+
----
Generate a brief customer support summary report. Follow the exact format structure provided.
----

. Test with a prompt:
+
----
Summarize today's customer support metrics: 150 tickets resolved, 23 escalated, average response time 4.2 minutes, customer satisfaction 94%.
----
+
Expected output format:
+
----
## REPORT START ##
### Daily Metrics ###
- Total tickets resolved, 150
- Escalated tickets, 23
- Average response time, 4.2 minutes
### Customer Satisfaction ###
- Overall satisfaction score, 94 percent
## REPORT END ##
----
+
image::module-02-figure-10.png[Grammar output showing structured report format with GBNF,align="center",width=600,link=module-02-figure-10.png^,title="Grammar Structured Output"]

**What they should notice:**

* Output follows the defined structure exactly
* Required delimiters (##, ###, -) are present
* No content outside the grammar rules

**When to use each method:**

[cols="1,1", options="header"]
|===
|Use Case |Best Method

|Simple choices (yes/no, categories)
|Choice mode

|Structured data (APIs, databases)
|JSON Schema

|Specific formats (IDs, codes)
|Regex

|Complex markup, reports, custom formats
|Grammar
|===

**Regex use cases for ACME:**

* **Ticket IDs**: Consistent format for tracking systems
* **Reference numbers**: Order IDs, invoice numbers, case numbers
* **Formatted data**: Phone numbers, dates, postal codes
* **Codes**: Product SKUs, department codes, status codes

**If asked:**

Q: "When would I use Grammar over JSON Schema?"
A: "Grammar is best for non-JSON structured output, like custom report formats, DSLs, or markup languages that your existing tools already parse."

Q: "Is Grammar mode slower than other modes?"
A: "Complex grammars can add overhead. For high-throughput scenarios, JSON Schema is generally faster. Use Grammar only when the output format genuinely requires it."

=== Reset Structured Outputs

Before moving on, disable Structured Outputs to reset the configuration:

. In the *Structured Outputs* panel, uncheck *Enable Structured Outputs*.
. Click the *Clear* button to start fresh.

== Troubleshooting

This section covers common issues across all structured output modes (Choice, JSON Schema, Regex, Grammar).

=== JSON Schema Issues

**Issue**: Output contains extra text before/after JSON

**Solution**:

. Ensure JSON Schema mode is properly selected
. Check that the schema is valid JSON
. Restart the server if mode changes don't take effect

**Issue**: Model outputs invalid enum values

**Solution**:

. Verify enum arrays are properly formatted in schema
. Ensure model supports guided decoding (check server logs)

=== Grammar Syntax Issues

**Issue**: Grammar syntax errors

**Solution**:

. Verify GBNF syntax is correct
. Test with simpler grammar first
. Check for missing quotes or escape characters

**Issue**: Model output doesn't match grammar

**Solution**:

. Ensure Grammar mode is selected (not JSON or Regex)
. Restart server after changing grammar
. Simplify grammar rules and test incrementally

=== General Structured Output Issues

**Issue**: Structured outputs not enforced (model ignores constraints)

**Solution**:

. Verify the server was started with structured output support
. Check server logs for guided decoding errors
. Some models may not support all constraint types

**Issue**: "Guided decoding not supported" error

**Solution**:

. Ensure you are using a compatible model
. Check vLLM version supports guided decoding
. Try a different model that supports constrained generation

**Issue**: Performance slower with structured outputs

**Solution**:

. This is expected, constraint checking adds overhead
. Use simpler constraints when possible
. For high throughput, consider JSON Schema over Grammar

== Module summary

**What was demonstrated:**

* Defined JSON Schema constraints for structured, API-ready customer support ticket extraction
* Implemented sentiment classification with constrained choice outputs
* Applied Regex patterns for ticket ID and phone number formatting
* Created Grammar rules for structured report generation
* Compared all four structured output methods and their ideal use cases

**Key takeaways:**

* Structured outputs transform unpredictable AI text into reliable, parseable data
* JSON Schema is ideal for API integration and database storage
* Choice mode handles simple classification tasks with zero ambiguity
* Regex excels at enforcing specific ID and code formats
* Grammar handles complex markup and custom structures
* Choose the simplest constraint method that meets the requirements

**Business value for ACME:**

* **Customer feedback automation**: 10,000+ daily messages automatically categorized with 98% accuracy, eliminating 20 hours of manual review
* **95% reduction in manual review time**: From 20 hours per day to 1 hour per day analyzing customer feedback
* **60% faster response to negative feedback**: Priority routing in under 2 minutes vs 30-minute manual triage
* **Real-time sentiment tracking**: Monitor 10,000+ daily messages with automated dashboards (previously batched weekly)
* **40% improvement in customer satisfaction scores**: Faster issue identification and resolution
* **$250,000 annual savings**: Reduced customer support operational costs through automation
* **Support ticket efficiency**: JSON-formatted tickets integrate directly with Salesforce, reducing data entry time by 75% (15 min to 4 min per ticket)
* **Consistent tracking**: Regex-validated ticket IDs enable 100% traceability across systems, reducing lost ticket incidents from 50/month to zero
* **Executive reporting**: Grammar-constrained reports generate automatically at 5 PM daily, saving 10 hours/week of manual report compilation
* **Total productivity gain**: 35 hours per week freed for high-value customer interactions, equivalent to adding 1 full-time support agent ($65K annual value)

**Next module:**

Module 3 explores *Advanced Inferencing: Tool Calling*, demonstrating how the AI can execute functions, retrieve data, and perform actions on behalf of users.

== References

* link:https://github.com/micytao/vllm-playground[vLLM Playground - Structured Outputs Documentation^]
* link:https://docs.vllm.ai/en/latest/serving/openai_compatible_server.html#guided-decoding[vLLM Guided Decoding^]
* link:https://json-schema.org/understanding-json-schema/[Understanding JSON Schema^]
* link:https://github.com/ggerganov/llama.cpp/blob/master/grammars/README.md[GBNF Grammar Reference^]
